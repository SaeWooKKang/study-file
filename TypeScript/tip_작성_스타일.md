# 올바른 타입 작성 스타일

#### 아이템 19
- 타입이 추론된다면, 타입 구문 작성 안하는게 좋음
- 모든 변수에 타입을 선언하는 것은 -> 비생산적, 형편없는 코드 
- 객체 리터럴과, 함수의 매개변수, 반환값은 타입 추론이 되더라도 타입 명시를 고려하자
  - 변수 할당시 구현상의 오류를 캐치할 수 있음 

#### 아이템 20
- js에서 변수에 값은 서로 다른 타입(strig | number)으로 재할당이 가능하지만, TS에서는 타입은 보통 바뀌지 않는다. 따라서 변수를 재사용 하지말고 분리해서 작성하자

#### 아이템 21: 타입 넓히기
- 타입 체크시 변수는 가능한 값들의 집합인 타입을 갖는다. 
- 타입을 명시적으로 작성하지 않으면 타입을 유추하는데 이 때 타입은 할당될 수 있는  값들의 집합이다. -> 타입 넓히기 
- 타입이 명시되지 않으면 타입 넓히기를 통해 타입을 추론한다.
- 타입 추론은 타입 넓히기를 통해 수행됨.

#### 아이템 22: 타입 좁히기
- 타입을 좁히면 작업이 훨씬 쉬워진다. 
- 다양한 처리 방법이 있다. 

#### 아이템 23: 한꺼번에 객체 생성하기
- 객체 생성시 속성을 추가하는 패턴 사용하지 말고, 한꺼번에 생성해라.

#### 아이템 24: 일관성 있는 별칭 사용하기
``` javascript
const person = {name: 'pac', andSoOn: {a:'1'}} 
const others = person.andSoOn; // others는 별칭 
```
- 타입 좁히기를 위해서 일관성 있게 비구조화 문법을 사용하자

#### 아이템 25: 비동기 코드에는 콜백 대신 async 함수 사용하기 
- 비동기 처리 패턴: 콜백 -> Promise(ES6) -> async (ES2017)
- 콜백 패턴은 중첩 깊이가 깊고, 코드를 안에서 부터 읽어야 한다.
- Promise는 코드를 위에서 아래로 읽을 수 있고, 중첩의 깊이 또한 낮고, reject시 예외를 던지는데 await와 try...catch 구문을 사용하여 캐치 가능. 
TS 관점에서의 장점
- 콜백 보다 프로미스가 타입을 추론하기 쉽다.

#### 아이템 26: 타입 추론에 문맥이 어떻게 사용되는지 이해하기
``` javascript
foo('javascript');

// -> 문맥으로부터 값을 분리

const js = 'javascript';
foo(js);
```
- 문맥으로부터 값을 분리하면 문제가 생길 수 있다. 
- 타입을 명시하거나 let키워드로 선언되어 있다면 const 키워드 사용해야 한다.
- 상수라면 as const 키워드를 쓸 수 있다. (사용한 곳에서 애러 발생함)

