# 올바른 타입 작성 스타일

#### 아이템 19
- 타입이 추론된다면, 타입 구문 작성 안하는게 좋음
- 모든 변수에 타입을 선언하는 것은 -> 비생산적, 형편없는 코드 
- 객체 리터럴과, 함수의 매개변수, 반환값은 타입 추론이 되더라도 타입 명시를 고려하자
  - 변수 할당시 구현상의 오류를 캐치할 수 있음 

#### 아이템 20
- js에서 변수에 값은 서로 다른 타입(strig | number)으로 재할당이 가능하지만, TS에서는 타입은 보통 바뀌지 않는다. 따라서 변수를 재사용 하지말고 분리해서 작성하자

#### 아이템 21: 타입 넓히기
- 타입 체크시 변수는 가능한 값들의 집합인 타입을 갖는다. 
- 타입을 명시적으로 작성하지 않으면 타입을 유추하는데 이 때 타입은 할당될 수 있는  값들의 집합이다. -> 타입 넓히기 
- 타입이 명시되지 않으면 타입 넓히기를 통해 타입을 추론한다.
- 타입 추론은 타입 넓히기를 통해 수행됨.

#### 아이템 22: 타입 좁히기
- 타입을 좁히면 작업이 훨씬 쉬워진다. 
- 다양한 처리 방법이 있다. 

#### 아이템 23: 한꺼번에 객체 생성하기
- 객체 생성시 속성을 추가하는 패턴 사용하지 말고, 한꺼번에 생성해라.

#### 아이템 24: 일관성 있는 별칭 사용하기
``` javascript
const person = {name: 'pac', andSoOn: {a:'1'}} 
const others = person.andSoOn; // others는 별칭 
```
- 타입 좁히기를 위해서 일관성 있게 비구조화 문법을 사용하자

#### 아이템 25: 비동기 코드에는 콜백 대신 async 함수 사용하기 
- 비동기 처리 패턴: 콜백 -> Promise(ES6) -> async (ES2017)
- 콜백 패턴은 중첩 깊이가 깊고, 코드를 안에서 부터 읽어야 한다.
- Promise는 코드를 위에서 아래로 읽을 수 있고, 중첩의 깊이 또한 낮고, reject시 예외를 던지는데 await와 try...catch 구문을 사용하여 캐치 가능. 
TS 관점에서의 장점
- 콜백 보다 프로미스가 타입을 추론하기 쉽다.

#### 아이템 26: 타입 추론에 문맥이 어떻게 사용되는지 이해하기
``` javascript
foo('javascript');

// -> 문맥으로부터 값을 분리

const js = 'javascript';
foo(js);
```
- 문맥으로부터 값을 분리하면 문제가 생길 수 있다. 
- 타입을 명시하거나 let키워드로 선언되어 있다면 const 키워드 사용해야 한다.
- 상수라면 as const 키워드를 쓸 수 있다. (사용한 곳에서 애러 발생함)

#### 아이템 27: 함수형 기법과 라이브러리로 타입 흐름 유지하기
- 직접 구현하기 보다는 내장된 함수형 기법과 유틸리티 라이브러리를 사용하자.

### 4장: 타입 설계
- 타입 시스템의 큰 장점은 타입을 명확히 알 수 있어 코드를 이해하기 쉽다. 
- 타입 자체의 설계를 다룬다. 

#### 아이템 28: 유효한 상태만 표현하는 타입을 지향하기 
- 효과적으로 타입을 설계하려면 유효한 상태만 표현할 수 있는 타입을 만들어야한다. 
- 유효한 상태, 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래한다. -> 분기 처리 하기 어려움 
- 타입 설계시 충돌될수 있는 상태를 명시적으로 구분하자(코드가 길어질 수는 있음)

#### 아이템 30: 문서에 타입 정보를 쓰지 않기 
- 주석은 코드와 동기화 되지 않는다.
- 주석에 타입 정보 쓰지 말 것. 
- 변수명에 타입 정보 쓰지 말 것.
- 타입 시그니처를 보고 알 수 있는것을 작성하지 말 것. 
- 타입 정보를 작성할 것 -> 수정되어도 유효하다.

#### 아이템 31: 타입 주변에 null 값 배치하기
- 동시에 초기화 되는 두개의 변수가 있을때, 하나의 변수로 null이 아님을 체크하는것은 타입 시스템에서는 표현할 수 없다. 
- 따라서 한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하면 안됨
#### 아이템 32: 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기 
요약
- 유니온의 인터페이스보다 인터페이스의 유니온이 타입스크립트가 이해하기 좋다. 
- 태그된 유니온을 사용할 수 있다면 사용하자 

이해
- 이전에 '__태그된 유니온__'이라는 말이 여러번 등장했지만 이번 아이템에서 '태그'라는 말을 이해할 수 있었다. 타입 설계시 무효화 될 수 있는 타입을 구분해서 작성 할 때 속성 중의 하나가 문자열 리터럴 타입이 되는데 이 속성(type)을 '__태그__'라고 한다.

- '__유니온의 인터페이스__'
  ``` javascript 
  interface Layer {
    layout: aLayout | bLayout | cLayout;
    paint: aPaint | bPaint | cPaint;
  }
  ```
- '__인터페이스 유니온__'
  ``` javascript
  interface aLayer {layout: aLayout; paint: aPaint}
  interface bLayer {layout: bLayout; paint: bPaint}
  interface cLayer {layout: cLayout; paint: cPaint}

  interface Layer = aLayer | bLayer | cLayer;
  ```
#### 아이템 33: string 타입보다 더 구체적인 타입 사용하기 

요약
- string 보다 더 구체적인 타입을 사용하자 
- 문자열 리터럴 타입의 유니온을 사용하자 
- 객체의 속성 이름을 매개변수로 받을 때는 keyof T를 사용하자 

이해
- K extends keyof T 가 이해가 잘안됨 
- extends 키워드 다시 보기 
- 두번째 제너릭 타입을 줘서 범위를 좁힌듯  ?

#### 아이템 34: 부정확한 타입보다는 미완성 타입을 사용하기
- 타입을 정밀하게 만들려고 실수 하지말고 
- 테스트 세트를 추가하여 놓친 부분이 없는지 확인하자

#### 아이템 35: 데이터가 아닌, API와 명세를 보고 타입 만들기
- 데이터를 보고 타입을 정의할 경우 예외가 있을 수 있음
- 타입 선언이 존재하면 다운받자 npm i --save -D @types/~~

이해 
- 예제가 GraphQL, Apollo 나오는데 뭔지 모르겠다.
- 저자의 의도는 이해 됨

#### 아이템 36: 해당 분야의 용어로 타입 이름 짓기
- 이름을 지을 때는 데이터 자체가 무엇인지를 고려해야 한다. 

이해
- 변수명 지을떄 oodata, oodatum 이런식으로 지은게 있었는데 이런 부분은 변경할 필요가 있겠다. 

### 5장: any 다루기 
- 마이그레이션시 타입 체크를 비활성화 시켜주는 any는 중요하다. 

#### 아이템 38: any 타입은 가능한 한 좁은 범위에서만 사용하기
- 함수의 반환값에 any 사용 x 
- 객체에 한 개의 속성이 타입 오류를 가지면 그 속성만 any 사용하기
- @ts-ignore를 사용하여 any를 사용하지 않고 오류 제거하기

#### 아이템 39: any를 구체적으로 변형해서 사용하기 
- any는 모든 값이 할당 가능하므로 더 구체적으로 표현 가능한 타입이 존재할 가능성이 높다. 
- 구체적으로 any를 작성해서 안정성을 높일 수 있다.
- 함수의 매개변수에 배열을 넣는다 할 때 any 대신 any[] 
- 함수의 매개변수에 객체를 넣는다 할 때 any 대신 {[key: string]: any}
- 함수 타입에도 () => any, (arg: any) => any, (...arg: any[]) => any 사용하기 

이해
- 마이그레이션시 noImplicityAny 설정키고, any 적용하고, 변경하면 될듯 ?

#### 아이템 41: any의 진화를 이해하기
- noImplicitAny가 설정되어 있고, 변수가 초기화 되어있지 않고 또는 배열이 빈배열이면 any는 진화한다. 
- any 진화 지양하고 명시적으로 작성하자 
``` javascript
let a; // null
if ( Math.randon() < 0.5 ) {
 let a = 11; // number
} else {
  let a = 'abc';
}
a // number | string
```

#### 아이템 42: 모르는 타입에는 any 대신 unknown 사용하기
- 반환값에 any를 사용하지말고 unknown을 사용하자 
- any를 사용하면 타입체커가 무용지물된다. 

이해
- unknown은 어떤 타입이든 unknown에 할당가능하고, 
- 할당은 unknown과 any만 가능함.

#### 아이템 44: 타입 커버리지를 추적하여 타입 안정성 유지하기
- noImplicitAny 설정하더라도 서드파티 타입 선언이 any인경우 any는 코드 전반에 영향을 미친다.
- 타입 커버리지를 추적하여 any의 사용량을 줄이고 타입 안정성을 높이자
