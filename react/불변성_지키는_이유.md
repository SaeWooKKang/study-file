# 리액트에서 불변성을 지키는 이유 

리액트는 상태를 얉은 비교를 통해 확인한다. 

얉은 비교란 변수에 할당된 값의 메모리 주소만을 확인하는 것인다. 

JS에는 원시값과 참조값이 있다. 

원시값은 문자, 숫자, null, undefined, boolean 

참조값은 객체이다. 

우선 원시값을 보면 

``` javascript
let foo = 'foo';
foo = 'foo';
```

변수 foo에 'foo'라는 문자열을 두 번 할당하고 있다.

원시값은 데이터 영역의 메모리에 할당된 값이 변경되지 않는다.

원시값은 무조건 메모리 공간을 새로 확보하고 데이터 값을 넣는다.

따라서 첫 번째 문자열 'foo'와 두 번째 문자열 'foo'는 문자는 같지만

서로 다른 메모리 주소에 저장된다. 

아래의 리액트 코드는 변수 foo에 초깃값 'foo'를 할당한 코드이다. 

``` javascript
const [foo, setFoo] = useState('foo');

setFoo('foo');
```

setFoo는 foo의 값을 변경하는 함수이고 

원시값을 할당하였으므로 참조하는 메모리 주소가 변경되게 된다.

따라서 리액트는 상태 변화를 감지하게되고 리렌더링 하게 되는것이다.

그러면 이제 객체를 보자 

``` javascript
let foo = { name: 'foo' };
foo.name = 'bar';
```

참조형인 객체는 새로운 객체를 할당하지 않는 이상 변수가 가리키고 있는 메모리 주소값 즉 참조가 변하지 않는다. 

따라서 객체에 프로퍼티를 변경해도 

변수 foo가 가리키고 있는 데이터의 참조값은 변하지 않는다.

그림으로 보면 더 쉽다. 

<img src='https://raw.githubusercontent.com/SaeWooKKang/study-file/master/Javascript/%EC%B0%B8%EC%A1%B0%ED%98%95_%EC%A0%80%EC%9E%A5.png'>

위의 그림은 예전에 만든거라 조금 다른데 

객체에 속성을 동적으로 변경하는 코드이다. 

왼쪽의 변경전 변수 person1은 데이터영역의 메모리 주소 11111을 가리키고 있다. 

오른쪽의 프로퍼티 변경한 코드에서도 person1 변수는 데이터 영역의 메모리 주소 11111을 가리키고 있는것을 볼 수 있다. 

결론적으로 person1이 가리키고 있는 메모리 주소는 같다. 

다시 본론으로 돌아와서  

따라서 다음과 같이 불변성을 지키지 않고 상태를 변경한다면 
리액트는 상태가 변경된것을 알아차리지 못한다.

``` javascript
const [foo, setFoo] = useState({ name: 'foo' });

foo.name = 'bar';
setFoo(foo);
```

그래서 스프레드 연산자로 얉은 복사하고 새로운 값을 넣어 주는것이다.

``` javascript
const [foo, setFoo] = useState({ name: 'foo' });


setFoo({ ...foo, name: 'bar' });
```

새로운 객체를 할당하였기에 변수 foo가 참조하는 데이터 값의 메모리 주소가 변경되고

리액트가 이를 알아차려 리렌더링 시키는 것이다. 

요약 하자면 

원시값은 애초에 변경 불가능하므로 원시값 할당시 불변성을 알아서 지켜주고, 

객체는 변경 가능하므로 불변성을 지켜주기 위해 스프레드 연산자로 얉은 복사를 해줘서

기존의 객체를 변경시키지 않고 불변성을 유지 해주는것이다. 

이렇게 상태에 불변성을 유지해주면 상태 변경시 리액트가 얉은 비교를 통해

변경된 것을 발견하고 리렌더링 시켜주는 것이다.