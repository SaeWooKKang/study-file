# 리액트에서 불변성을 지키는 이유 

리액트는 상태를 얉은 비교를 통해 확인한다. 

얉은 비교란 변수에 할당된 값의 메모리 주소만을 확인하는 것인다. 

JS에는 원시값과 참조값이 있다. 

원시값은 문자, 숫자, null, undefined, boolean 

참조값은 객체이다. 

우선 원시값을 보면 

``` javascript
let foo = 'foo';
foo = 'foo';
```

변수 foo에 'foo'라는 문자열을 두 번 할당하고 있다.

원시값은 데이터 영역의 메모리에 할당된 값이 변경되지 않는다.

원시값은 무조건 메모리 공간을 새로 확보하고 데이터 값을 넣는다.

따라서 첫 번째 문자열 'foo'와 두 번째 문자열 'foo'는 문자는 같지만

서로 다른 메모리 주소에 저장된다. 

아래의 리액트 코드는 변수 foo에 초깃값 'foo'를 할당한 코드이다. 

``` javascript
const [foo, setFoo] = useState('foo');

setFoo('foo');
```

setFoo는 foo의 값을 변경하는 함수이고 

원시값을 할당하였으므로 참조하는 메모리 주소가 변경되게 된다.

따라서 리액트는 상태 변화를 감지하게되고 리렌더링 하게 되는것이다.

그러면 이제 객체를 보자 

``` javascript
let foo = { name: 'foo' };
foo.name = 'bar';
```

참조형인 객체는 새로운 객체를 할당하지 않는 이상 변수가 가리키고 있는 메모리 주소값 즉 참조가 변하지 않는다. 

따라서 객체에 프로퍼티를 변경해도 

변수 foo가 가리키고 있는 데이터의 참조값은 변하지 않는다.

그림으로 보면 더 쉽다. 

<img src='https://raw.githubusercontent.com/SaeWooKKang/study-file/master/Javascript/%EC%B0%B8%EC%A1%B0%ED%98%95_%EC%A0%80%EC%9E%A5.png'>


따라서 다음과 같이 불변성을 지키지 않고 상태를 변경한다면 
리액트는 상태가 변경된것을 알아차리지 못한다.

``` javascript
const [foo, setFoo] = useState({ name: 'foo' });

foo.name = 'bar';
setFoo(foo);
```

그래서 스프레드 연산자로 얉은 복사하고 새로운 값을 넣어 주는것이다.

``` javascript
const [foo, setFoo] = useState({ name: 'foo' });


setFoo({ ...foo, name: 'bar' });
```

새로운 객체를 할당하였기에 변수 foo가 참조하는 데이터 값의 메모리 주소가 변경되고

리액트가 이를 알아차려 리렌더링 시키는 것이다. 