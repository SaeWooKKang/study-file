# 메모리 주소

## 생각해보기
'CS50'을 16진수로 표현해볼까요?
```
C (10진수: 67(64 + 2 + 1)      2진수: 0100 0011) -> 16진수: Ox43  
S (10진수: 83(64 + 16 + 2 + 1) 2진수: 0101 0011) -> 16진수: Ox53  
5 (10진수: 53(32 + 16 + 4 + 1) 2진수: 0011 0101) -> 16진수: Ox35
0 (10진수: 48(32 + 16)         2진수: 0011 0000) -> 16진수: Ox30
-> Ox43533530  
```

## 요약
- 1 2 3 4 5 6 7 8 9 a b c d e f(15)
- 16진수와 10진수를 구분하기 위해 접두사로 **0x**를 붙인다

- 컴퓨터 과학에서는 숫자를 16진수(Hexadecimal)로 표현하는 경우가 많다.
- 데이터를 처리하는데 장점이 있기 때문
- 16진수를 사용하면 10진수보다 2진수를 간단하게 나타낼 수 있다.


### 각 자리가 1로 전부 채워진 이진수를 십진수로 빠르게 읽기

11 = 2^1 * 1 + 2^0 * 1 = 3  
11은 100(2^2 * 1 + 2^1 * 0 + 2^0 * 0) -1이다.  
따라서 2^2 - 1로 계산하면 빠르게 계산 가능하다.

``` 
1111 1111은 ?

2^8 - 1 = 255이다.
```


### 10진수를 16진수로 바꾸기 

```
10진수:    255        216        255
2진수 : 1111 1111  1101 1000  1111 1111
16진수:    Oxff       Oxd8       Oxff
```

###  16진수의 장점
1byte = 8bit = 2^8 = 256  

ASCII 코드에서 'A'는 10진수로 65   
2진수로 나타내면 0100 0001   

길이가 너무 길다.  

4bit 즉 16을 16진수로 나타내면 간단해진다.  

컴퓨터의 메모리 단위는 바이트이고 바이트는 2^8이다  
16진수는 2^4이고 1바이트를 16진수 2개로 표현할 수 있다.  
따라서 정보를 표현하기 매우 유용하다.   

컴퓨터의 정보 표현은 1byte 단위이다.   

### 메모리 주소 얻기
메모리 주소 얻기 위해 '&'연산자 사용  
형식 지정자 'p'는 pointer의 약자  
``` c
#include <stdio.h>

int main(void)
{
  int n = 50; 
  printf("%p\n", &n); // '0x7ffe00b3adbc'
}
```

" *& "를 사용하여 메모리 주소에 있는 실제 값 얻기
n의 주소를 얻고, 다시 주소에 해당하는 값 얻는 코드
``` c
#include <stdio.h>

int main(void)
{
  int n = 50;
  printf("%i\n", *&n);// 50
}
```

### 의문
컴퓨터는 2진수 0과 1로 이루어진 것 만 이해할 수 있는데 16진수를 어떻게 이해하지..  
10진수처럼 사람이 이해할 수 있게 표현한것 뿐인가 ?  

- 위의 예시에서 메모리 주소를 보여줄 때 16진수로 보여줬는데 2진수로 보여줬으면 매우 길었을것이다. 
- 컴퓨터는 2진수로 저장하지만 사람이 보기 편하게 16진수로 바꿔서 보여주는듯하다.

