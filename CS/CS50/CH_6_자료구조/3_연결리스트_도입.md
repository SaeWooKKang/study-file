# 연결리스트: 도입

## 생각해보기
연결 리스트를 배열과 비교했을 때 장단점은 무엇이 있을까요?
```
연결리스트는 데이터가 계속해서 추가되는 상황에서 최소한의 메모리만 사용할 수 있다는 장점이 있다.  

반면에 배열은 필요한 메모리를 미리 확보하거나 복사 하는 과정이 필요하므로 비효율 적이다.  

단점은 배열처럼 인덱스로 임의 접근이 불가능하고 순차 접근 해야한다.  
```

노드
> 컴퓨터 과학에서 노드는 직사각형으로 나타낼 수 있는 메모리 덩어리

데이터 구조
> 메모리를 좀 더 효율적으로 관리하고 사용하기 위해 새로 정의하는 구조체

## 요약

배열은 요소가 메모리에 연속적으로 저장되어 있다. 

미리 확보한 메모리 크기를 초과한다면 

메모리를 동적으로 할당하고 복사하여야 한다.

따라서 O(n)의 시간복잡도를 가진다.

연결 리스트를 사용하면 이러한 단점을 상쇄시킬 수 있다.  

비록 임의 접근이 불가능하다는 단점이 있지만 

유동적으로 변하는 데이터를 관리하는데는 효율적이다.

필요한 최소한의 메모리만 사용하다가 데이터가 늘어난다면 

마지막 node에 다음 node를 '연결'만 해주면 되기 때문이다. 

메모리상의 여러 군데 나뉘어져 있다고 하더라도 바로 다음 값의 메모리 주소만 기억하고 있다면 여전히 값을 연이어서 읽을 수 있다.  

![](https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png)

위와 같이 요소의 값과 다음 주소를 함께 기억하는 형태이다.  

구조체를 정의하면 다음과 같다.  
``` c
typedef struct 
{
  int number; 
  node *next; // 데이터 구조 node 가리킴
}
node
```

위와 같이 작성하면 컴퓨터는 위에서 아래로 좌에서 우로 읽기에 
node를 읽을 수 없다.  

따라서 다음과 같이 사용하고자하는 단어를 추가한다.    

``` c
typedef struct node // 구조체의 정식 명칭
{
  int number;
  struct node *next;
}
node; // 구조체의 별명
```

#### 배열의 장점
- 대괄호를 이용해서 문법적으로도 쉽게 인덱싱 할 수 있다.
- 랜덤 접근이라는 방법으로 일정한 시간에 접근 할 수 있다.
- 무엇이 어디에 있는지 알 수 있다는 면에서 랜덤은 아니다
- 괄호에 0,1,2 등을 써서 바로 그 자리에 접근 할 수 있다.

#### 추가 

##### Random-Access Memory(RAM)

램은 임의의 영역에 접근하여 읽고 쓰기가 가능한 주기억 장치이다. 
램은 어느 위치에 저장된 데이터든지 접근하는 데 동일한 시간이 걸리는 메모리이게 랜덤(무작위) 이라는 명칭이 주어진다.

#### 더 생각해보기 
배열은 랜덤 접근이 가능한데 연결리스트는 왜 안될까 ?
```
int num[3];
배열은 num[2]를 접근 한다고 했을 때 
num의 메모리 주소 + (자료형의 크기 * 인덱스)로 
일정한 속도로 접근이 가능하다. 

반면에 연결리스트는 num -> next -> number와 같이
처음 부터 순회해서 접근해야한다. 
```