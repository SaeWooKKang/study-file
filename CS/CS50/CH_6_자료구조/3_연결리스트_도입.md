# 연결리스트: 도입

## 생각해보기
연결 리스트를 배열과 비교했을 때 장단점은 무엇이 있을까요?
```
연결리스트는 요소를 추가할 때 포인터의 위치만 변경하면 되므로 배열보다 효율적이다. 

단점으로는 하나의 요소를 저장하는데 메모리 주소도 함께 저장하므로 메모리가 추가로 소모된다.
```

노드
> 컴퓨터 과학에서 노드는 직사각형으로 나타낼 수 있는 메모리 덩어리

데이터 구조
> 메모리를 좀 더 효율적으로 관리하고 사용하기 위해 새로 정의하는 구조체

## 요약

배열은 요소가 메모리에 연속적으로 저장되어 있다. 

메모리의 크기를 늘리려면 메모리를 동적으로 할당하고 복사하여  

O(n)의 시간복잡도를 가졌었다.  

연결 리스트를 사용하면 이러한 단점을 상쇄시킬 수 있다.  

메모리상의 여러 군데 나뉘어져 있다고 하더라도 바로 다음 값의 메모리 주소만 기억하고 있다면 여전히 값을 연이어서 읽을 수 있다.  

![](https://cs50.harvard.edu/x/2020/notes/5/linked_list_with_addresses.png)

위와 같이 요소의 값과 다음 주소를 함께 기억하는 형태이다.  

구조체를 정의하면 다음과 같다.  
``` c
typedef struct 
{
  int number; 
  node *next; // 데이터 구조 node 가리킴
}
node
```

위와 같이 작성하면 컴퓨터는 위에서 아래로 좌에서 우로 읽기에 
node를 읽을 수 없다.  

따라서 다음과 같이 사용하고자하는 단어를 추가한다.    

``` c
typedef struct node // 구조체의 정식 명칭
{
  int number;
  struct node *next;
}
node; // 구조체의 별명
```

#### 배열의 장점
- 대괄호를 이용해서 문법적으로도 쉽게 인덱싱 할 수 있다.
- 랜덤 접근이라는 방법으로 일정한 시간에 접근 할 수 있다.
- 무엇이 어디에 있는지 알 수 있다는 면에서 랜덤은 아니다
- 괄호에 0,1,2 등을 써서 바로 그 자리에 접근 할 수 있다.

#### 추가 

##### Random-Access Memory(RAM)

램은 임의의 영역에 접근하여 읽고 쓰기가 가능한 주기억 장치이다. 
램은 어느 위치에 저장된 데이터든지 접근하는 데 동일한 시간이 걸리는 메모리이게 랜덤(무작위) 이라는 명칭이 주어진다.

#### 더 생각해보기 
배열은 랜덤 접근이 가능한데 연결리스트는 왜 안될까 ?
```
int num[3];
배열은 num[2]를 접근 한다고 했을 때 
num의 메모리 주소 + (자료형의 크기 * 인덱스)로 
일정한 속도로 접근이 가능하다. 

반면에 연결리스트는 num -> next -> number와 같이
처음 부터 순회해서 접근해야한다. 
```