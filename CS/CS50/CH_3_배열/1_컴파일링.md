# 컴파일링

##### 생각해보기
만약 컴파일링 과정을 거치지 않기 위해 바로 머신코드로 우리가 원하는 프로그램을 작성하려고 한다면 어떤 문제가 있을까요?
```
인간에게 좀 더 친숙한 언어인 C를 두고 굳이 머신코드로 작성한다면
코드를 작성하는데 시간이 오래 걸리고 개발 비용이 늘어날것이다.
```

---

## 컴파일링의 4단계
- 소스코드가 머신코드로 컴파일시 다음의 네 단계를 거친다.
- 컴파일의 결과는 실행 가능한 파일이다.
- 어셈블리 코드는 cpu가 이해할 수 있는 저수준의 언어다.

1. Precompile 
  - 전처리기에 의해 수행
  - #으로 시작되는 소스코드는 전처리기에의해 실행됨
  - #include는 전처리기에게 다른 파일의 내용을 포함시키라 알려줌
2. Compile
  - 컴파일러가 C코드를 어셈블리어(기계에게 친숙한 저수준 프로그래밍언어)로 컴파일함
  - 소스 코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 일컫기도 함
3. Assemble 
  - 어셈블러가 어셈블리 코드를 오브젝트 코드(머신 코드)로 변환시킴
  - 0과 1로 이루어짐
4. Link
  - 만약 프로그램이 cs50같은 라이브러리를 사용한다면 여러 개의 파일로 이루어져있는 것을 하나의 오브젝트 파일로 합쳐줌
  - 여러 개의 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐줌 

## 어셈블러의 이해
1950년대 초, 단순한 반복 작업을 처리하기 위한 프로그램이 몇 가지 만들어졌다.  

특정한 처리를 수행하는 프로그램을 **어셈블러**라고 한다.  

이 프로그램에 작성되는 언어는 **어셈블리 언어**  

이 수준의 프로그래밍을 **어셈블리 언어 프로그래밍**이라한다.  

어셈블러는는 명령어아 데이터 값이 메모리상 어느 위치에 있는지 파악해준다. 따라서 프로그래머가 직접 관리 하지 않아도 된다.  

어셈블리 언어는 프로세서 아키텍처에 특화된 언어고 프로세서 명령어와 일대일로 연결된다. 따라서 프로세서에 종속적이다.  

**고수준 언어**는 프로세서 아키텍처에 독립적이다.   
> 1950년대 말 1960년대 초에 등장

이전에는 각 프로세서에 맞춰서 어셈블리어를 작성했다면 한 단계 추상화하여 프로세서에 독립적인 고수준 언어로 작성하고 각 아키텍처에 맞게 컴파일러로 변환할 수 있게 되었다.  

고수준 언어는 컴파일러를 통해 어셈블리 언어로 변환되고 어셈블러를 통해 머신 코드로 변환되어 메모리에 로드되고 실행된다.  